/*
题目描述
一个只包含'A'、'B'和'C'的字符串，如果存在某一段长度为3的连续子串中恰好'A'、'B'和'C'各有一个，
那么这个字符串就是纯净的，否则这个字符串就是暗黑的。例如：
BAACAACCBAAA 连续子串"CBA"中包含了'A','B','C'各一个，所以是纯净的字符串
AABBCCAABB 不存在一个长度为3的连续子串包含'A','B','C',所以是暗黑的字符串
你的任务就是计算出长度为n的字符串(只包含'A'、'B'和'C')，有多少个是暗黑的字符串。
输入描述:
输入一个整数n，表示字符串长度(1 ≤ n ≤ 30)
输出描述:
输出一个整数表示有多少个暗黑字符串
示例1
输入

2 3
输出

9 21
*/
/*
主要在于数学规律的推导：
f(n):表示长度为n的暗黑字符串个数。
s(n):长度为n，且末尾两个字符相同的暗黑字符串个数。
d(n):长度为n，且末尾两个字符串不同的暗黑字符串个数。
f(n)=d(n)+s(n);                        ---(1)
对于长度为n-1的字符串来说，如果末尾两个字符是相同的，扩展为长度为n字符串时：有3*s(n-1)种；
如果末尾两个字符是不同的，扩展为长度为n字符串时：有2*d(n-1)种
所以：
f(n)=3s(n-1)+2d(n-1)=2f(n-1)+s(n-1);----关键(2)
又分析可得：
s(n)=d(n-1)+s(n-1);                 ---(3)
d(n)=2s(n-1)+d(n-1);
(1)(3)可得：f(n-1)=s(n);
最后得递推公式：
f(n)=2f(n-1)+f(n-2);
*/
#include<bits/stdc++.h>
using namespace std;
long anheistring(long n)
{
    if(n==1)
    return 3;
    else if(n==2)
    return 9;
    else 
    return 2*anheistring(n-1)+anheistring(n-2);
}
int main()
{
    long n;
    while(cin>>n)
    {
        cout<<anheistring(n);
    }
    return 0;
}