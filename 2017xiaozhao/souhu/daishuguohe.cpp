/*
题目描述
一只袋鼠要从河这边跳到河对岸，河很宽，但是河中间打了很多桩子，每隔一米就有一个，每个桩子上都有一个弹簧，
袋鼠跳到弹簧上就可以跳的更远。每个弹簧力量不同，用一个数字代表它的力量，如果弹簧力量为5，
就代表袋鼠下一跳最多能够跳5米，如果为0，就会陷进去无法继续跳跃。河流一共N米宽，袋鼠初始位置就在第一个弹簧上面，
要跳到最后一个弹簧之后就算过河了，给定每个弹簧的力量，求袋鼠最少需要多少跳能够到达对岸。如果无法到达输出-1
输入描述:
输入分两行，第一行是数组长度N (1 ≤ N ≤ 10000)，第二行是每一项的值，用空格分隔。
输出描述:
输出最少的跳数，无法到达输出-1
示例1
输入

5
2 0 1 1 1
输出

4
*/
/*
典型的动态规划思想。注意初始化的时候用一个较大的数来初始化即可
*/
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    while(cin>>n)
    {
        vector<int> data;
        int dp[n+1];
       //  memset(dp,INT_MAX,sizeof(dp));//注意memset是一个字节一个字节赋值的，只能用memset(0),最好不乱设置其他值
        dp[0]=0;
        for(int i=1;i<=n;i++)
        {
            dp[i]=10001;
        }
        for(int i=0;i<n;i++)
        {
            int temp;
            cin>>temp;
            data.push_back(temp);
        }
        for(int i=1;i<=n;i++)
        {
            for(int j=0;j<i;j++)
            {
                if(j+data[j]>=i)//如果前面有个数加上它能够到达的范围比当前的数要大，则动态规划。
                dp[i]=min(dp[i],dp[j]+1);
            }
        }
        if(dp[n]!=10001)
        cout<<dp[n];
        else
        cout<<-1;
    }
    return 0;
}